thread_pool, as the name implies, is to create many threads. The function pthread_creat () that creates a thread should be the most easily thought. When a thread is created, there is a thread exiting pthread_exit(). If the thread does not set the pthread_detach() property before the thread exits, then obviously the thread resource pthread_join() should be recovered. Of course, you may want to get the ID value of the thread pthread_self ().
2. The first step is to create a thread. At the beginning, the thread does not do anything. It initializes and waits. Waiting is certainly not a while (1) function, because it consumes too much CPU resources. The easy-to-think-of wait is, of course, a conditional variable wait pthread_cond_wait(), which does two things: the first is to unlock the mutex corresponding to the parameter mutex, and the second is to re-lock it so that the thread puts the task into a buffer on the task queue. When the task is put in place and then locked, it will not affect the right of other tasks to get the lock. Therefore, before calling this function, you will naturally think of adding mutex locks. The initialization mutex function pthread_mutex_init(), the de-initialization mutex function pthread_mutex_destroy(), the locking function pthread_mutex_lock(), and the unlocking function pthread_mutex_unlock () are slightly refined and may be used to try to unlock pthread_mutex_trylock ().
3., to achieve the above two steps, the framework of a thread pool is initially built up. Of course not, because the threads that actually do things are all waiting, be careful not to wait for pthread_cond_timewait () overtime. To make a blocked thread work, signal it to wake up a function of the pthread_cond_signal (), "shoot a bird" and always wake the bird up, but specifically the one, look at the queue that first queued up there (the pthread_cond_wait () function has been said above). Of course, you can also think of the function pthread_cond_broadcast () of "shooting the birds and startling the flock". If you shoot one shot, a flock of birds fly away.

4, with the above foundation, the next task is to focus on the task. Of course, the number of threads is limited. As mentioned above, it is a fixed number. Therefore, queues are inevitable when tasks are greater than threading. Therefore, a task queue is created, and each item in the queue represents a task. The simplest model of a node in a task queue is a callback function void (* callback_function) (void * arg) that handles the task. Pointer to function. The parameter is a pointer, and the return value is a pointer. Specific functions and parameters need to write another function definition. Each time the thread is processed, the task needs to be deleted from the task queue. The number of tasks entering the task queue can't be infinite, so it's also set to a fixed value a few times larger than the number of threads.
5. Thread Dynamic Creation: After a thread exits (it may exit if the task fails), the main thread must be able to detect it, and then create a new thread dynamically to keep the total number of threads in the thread pool unchanged. You can block the wait to reclaim the child thread resource by pthread_join(), but that means the main thread can't do anything else in the blocked state, so consider using a thread signal to send a SIGUSR1 signal to the main thread with pthread_kill() at the end of the child thread, and when the main thread receives the signal, pass Call the registration function signal () or sigaction () function to create a new thread.
